# Functional-Light JavaScript
# Chapter 1: Why Functional Programming?

> Functional programmer: (noun) One who names variables "x", names functions "f", and names code patterns "zygohistomorphic prepromorphism"
>
> James Iry ‏@jamesiry 5/13/15
>
> https://twitter.com/jamesiry/status/598547781515485184

Functional Programming (FP) ဆိုတာ အယူအဆ အသစ်တစ်ခုတော့လုံးဝ မဟုတ်ပါဘူး။ Programming စကတည်းကရှိနေခဲ့တာပါ။ အခုလိုပြောရင် မျှတပါ့မလား မသိပေမယ့်၊  လွန်ခဲ့တဲ့ နှစ်အနည်းငယ်မတိုင်ခင် အထိ developer နယ်ပယ်မှာ ရေပန်းစားတဲ့ အယူအဆတစ်ခု မဟုတ်ခဲ့တာတော့ သေချာပါတယ်။ FP ဟာ သင်ကြားရေးနယ်ပယ်မှာ ပိုနာမည်ကြီးတယ်လို့ကျနော်ထင်ပါတယ်။

ဒါပေမယ့် အဲ့ဒါတွေ အကုန်လုံးက စိန်ခေါ်မှုတွေပါပဲ။ FP နဲ့ ပတ်သက်ပြီး စိတ်ဝင်စားမှု မြင့်တက်လာတာက languages အဆင့်သာမကပဲ libraries တွေ frameworks တွေအထိပါပဲ။သင်အခုဒီစာကိုဖတ်နေတာကလည်း FP ဆိုတာ လှစ်လျူရှုထားလို့ မရတော့ဘူးလို့ သင်သဘောပေါက်လို့လဲ ဖြစ်ကောင်းဖြစ်မှာပါ။ ဒါမှ မဟုတ်သင်ဟာ ကျနော့်လိုပဲ FP ကို အရင်က အကြိမ်ပေါင်းများစွာကြိုးစားဖူးပေမယ့် အခေါ်အဝေါ်တွေ သင်္ချာ အသုံးအနှုန်းတွေကြားမှာ ရုန်းကန်နေရတာလည်း ဖြစ်နိုင်ပါတယ်။ 

ပထမ သင်ခန်းစာရဲ့ ရည်ရွယ်ချက်က "ဘာလို့ ငါ့ရဲ့ code တွေကို FP စတိုင်သုံးရမှာလဲ" နဲ့ "Javascript ရဲ့ FP နဲ့ တခြား FP ကို ဘယ်လိုနှိုင်းယှဉ်မှာလဲ" ဆိုတဲ့ မေးခွန်းလိုမျိုးတွေကို ရှင်းပြဖို့ လိုအပ်တာတွေ လုပ်သွားမှာဖြစ်ပါတယ်။ Chapter 2 ကနေစပြီး စာအုပ်ပြီးတဲ့ အထိ JS ကို functional lite ပုံစံမျိုး ဘယ်လိုရေးမလဲဆိုတာ တစ်ပိုင်းတစ်ပိုင်း ရှင်းပြသွားမှာပါ။

## At A Glance
Functional-Lite Javascript ရဲ့ သဘောကို before-and-after code နဲ့ အတိုချုပ်သရုပ်ပြကြည့်ရအောင်။ စဉ်းစားကြည့်ပါ။

```js
var numbers = [4,10,0,27,42,17,15,-6,58];
var faves = [];
var magicNumber = 0;

pickFavoriteNumbers();
calculateMagicNumber();
outputMsg();                // The magic number is: 42

// ***************

function calculateMagicNumber() {
    for (let fave of faves) {
        magicNumber = magicNumber + fave;
    }
}

function pickFavoriteNumbers() {
    for (let num of numbers) {
        if (num >= 10 && num <= 20) {
            faves.push( num );
        }
    }
}

function outputMsg() {
    var msg = `The magic number is: ${magicNumber}`;
    console.log( msg );
}
```
အဖြေတော့ အတူတူပဲ၊ မတူတဲ့ ပုံစံ တစ်ခုကို စဉ်းစားကြည့်ပါ။

```js
var sumOnlyFavorites = FP.compose( [
    FP.filterReducer( FP.gte( 10 ) ),
    FP.filterReducer( FP.lte( 20 ) )
] )( sum );

var printMagicNumber = FP.pipe( [
    FP.reduce( sumOnlyFavorites, 0 ),
    constructMsg,
    console.log
] );

var numbers = [4,10,0,27,42,17,15,-6,58];

printMagicNumber( numbers );        // The magic number is: 42

// ***************

function sum(x,y) { return x + y; }
function constructMsg(v) { return `The magic number is: ${v}`; }
```
FP နဲ့ Functional-Light ကိုသင်နားလည်ပြီဆိုရင် ဒုတိယ စာပိုဒ်ကို ဖတ်ပြီး  စိတ်ထဲကနေ နားလည်အောင်ကြိုးစားတဲ့အခါ ဒါမျိုးဖြစ်ကောင်းဖြစ်ပါလိမ့်မယ်။

> ကျနော်တို့ functions သုံးခုပေါင်းထားတဲ့ `sumOnlyFavourites(..)`function တစ်ခုကို တည်ဆောက်တယ်။ value တစ်ခုက 10 (သို့) 10 ထက်ကြီးလား စစ်တဲ့ filter နှင့် 20 သို့ 20 ထက်ငယ်လား စစ်တဲ့ filter နှစ်ခုကို ပေါင်းထားတယ်။
> နောက်ပြီး transducer composition မှာ `sum(..)` reducer ကို ပေါင်းထည့်တယ်။ ရလာတဲ့ `sumOnlyFavourites(..)` က ထည့်လိုက်တဲ့ value တစ်ခုက filters နှစ်ခုစလုံးကို pass လား၊ pass တယ်ဆိုရင် accumulator value ထဲကို ပေါင်းထည့်တဲ့ reducer function တစ်ခုဖြစ်လာတယ်။

> နောက်ပြီး `printMagicNumber(..)`လို့ခေါ်တဲ့ function တစ်ခုလုပ်တယ်။ အဲ့ဒီ function က `sumOnlyFavourites(..)` သုံးပြီး numbers list ကို ပထမဆုံး reduce လုပ်တယ်။ "favourite" check ကို pass လာတဲ့ numbers တွေပဲ ပေါင်းထားတဲ့ ရလဒ် ရလာမယ်။ နောက်ပြီး `printMagicNumber(..)`ကနေ နောက်ဆုံး ပေါင်းလဒ်ကို `constructMsg(..)`ထဲထည့်ပေးပြီး ရလာတဲ့ string value ကို နောက်ဆုံး `console.log(..)` ထဲပို့လိုက်တယ်
> 

FP developer တစ်ယောက် သုံးနှုန်းတဲ့ ဒီရွေ့လျားနေတဲ့ အစိတ်အပိုင်းတွေဟာ သင်နဲ့ လုံးဝ စိမ်းရင်စိမ်းနေမှာပါ။ သင်လည်း ဒီလိုပြောဆို သုံးနှုန်းတတ်လာအောင် ဒီစာအုပ်က သင်ပေးမှာပါ။ ဒီ code တွေဟာ သင့်ရဲ့ တစ်ခြား code တွေလိုပဲ readable ဖြစ်လာမှာပါ။ ပိုပြီးတောင် readable ဖြစ်နိုင်ပါတယ်။

အခု code နှိုင်းယှဉ်မှုနှင့်ပတ်သတ်ပြီး မှတ်ချက်အချို့၊

* စာဖတ်သူတော်တော်များများအတွက် အရင် snippet က နောက်ပိုင်း snippet ထက် ပိုပြီး သက်သာမယ်၊ ဖတ်ရအဆင်ပြေမယ်၊ ထိန်းသိမ်းရ လွယ်ကူမယ်လို့ ခံစားရနိုင်ပါတယ်။ အဲ့ဒီလိုထင်ရင်လည်း လုံဝ အဆင်ပြေပါတယ်။ သင်မှန်ပါတယ်။ သင်ဟာ စာအုပ်တစ်ခုလုံး အဆုံးအထိဖတ်မယ်၊ ဆွေးနွေးတဲ့ အကြောင်းအရာတွေအကုန် လေ့ကျင့်မယ် ဆိုရင် ဒုတိယ snippet က တစ်ခါတလေ ပိုပြီး သဘာဝ ကျမယ်၊ ပိုပြီးတော့တောင် သုံးသင့်မယ်လို့ ယုံကြည်ပါတယ်။

* သင်ဟာ အပေါ်က နှစ်ခုစလုံးနဲ့ မတူပဲ လုံဝ ကွဲပြားခြားနားပြီး ကောင်းမွန်တဲ့ ပုံစံနဲ့ task တွေကို ဖြေရှင်းခဲ့တာလည်းဖြစ်နိုင်ပါတယ်။ အဲ့လိုဆိုလည်း အဆင်ပြေပါတယ်။ ဒီစာအုပ်ဟာ ဒီနည်းအတိုင်း ဒီလိုပဲလုပ်ပါလို့ ပြောမှာ မဟုတ်ပါဘူး။ ရည်ရွယ်ချက်က မတူတဲ့ patterns တွေရဲ့ ကောင်းကွက်၊ဆိုးကွက်တွေကို သရုပ်ပြပြီး သင့်ကိုမှန်ကန်တဲ့ ဆုံဖြတ်ချက်တွေချနိုင်အောင်ပါ။ ဒီစာအုပ်ဖတ်လို့ပြီးရင် ပုဒ်စာ တစ်ခုကို ဖြေရှင်းဖို့ ချည်းကပ်တဲ့အခါ ဒုတိယ snippet နဲ့ ပိုရင်းနီးမှာပါ။

* သင့်အတွက် အသုံးဝင်တဲ့ ဖတ်စရာ တစ်ခုခုများရှိမလားလို့ စာအုပ်အစမှာ ရှာဖွေနေတဲ့ အတွေ့အကြုံရှိပြီးသား FP developer လည်း ဖြစ်နိုင်ပါတယ်။ ဒုတိယ snippet မှာ ရင်းနှီးပြီးသား အစိတ်အပိုင်းတွေ အသေအချာ ရှိပါတယ်။ ငါဆိုရင်တော့ အဲ့လိုလုပ်ခဲ့မှာ မဟုတ်ဘူးလို့ မကြခဏ တွေးနေမယ်လို့လည်း လောင်းပါတယ်။ အဲ့လိုတွေးတာလည်း အဆင်ပြေပြီး ဆီလျော်ပါတယ်။

 အခုစာအုပ်ဟာ သမရိုးကျ FP စာအုပ် မဟုတ်ပါဘူး။ ကျနော်တို့က တခါတရံ ကိုယ်ပိုင် ချည်းကပ်မှုကို တော်တော်လေး ယုံကြည်ကြတယ်။  FP ရဲ့ ငြင်းမရတဲ့ ကောင်းကွက်တွေနဲ့ ခက်ခဲတဲ့ သင်္ချာ၊ သင်္ကေတ၊ အသုံးအနှုန်း တွေမပါပဲ အလုပ်လုပ်တယ်၊ maintainable ဖြစ်တဲ့ JS တွေရဲ့ ကြားက လက်တွေ့ဆန်တဲ့ balance ကိုရှာဖွေကြမှာပါ။ ဒါဟာ သင့်ရဲ့ FP မဟုတ်ပါဘူး။ "Functional-Lite JavaScript" ပဲဖြစ်ပါတယ်။

ဒီစာအုပ်ကို ဘယ်လို အကြောင်းကြောင့်ပဲဖတ်ဖတ် ကြိုဆိုပါတယ်။

## Confidence

 JavasScript သုံးပြီး software developer ဆရာအဖြစ် အလုပ်လုပ်ရင်း ကျနော့မှာ အလွန်ရိုးရှင်းတဲ့ ယူဆချက်ရှိပါတယ်။ အဲ့ဒါက သင်ယုံလို့မရတဲ့ code က သင်နားမလည်တဲ့ code ပါပဲ။ ပြောင်းပြန်ဆိုလည်းမှန်ပါတယ်။ သင်နားမလည်တဲ့ code ဟာ သင် ယုံလို့ မရတဲ့ code ပါပဲ။ နောက်ပြီး သင့် code ကို ယုံလို့မရဘူး နားမလည်ဘူးဆိုရင် သင့်ရဲ့ code ဟာ ပြသနာအတွက် သင့်တော်တယ်လို့ ယုံကြည်ချက် မရနိုင်ပါဘူး။ သင့်ရဲ့ program ကို run ကြည့်ပြီး ကံကောင်းပါစေဆုတောင်းရမှာပါ။

ဒီနေရာမှာ ယုံကြည်မှုဆိုတာ သင်က သင့် code ကို run ကြည့်မှ မဟုတ်ပဲ ဖတ်ကြည့်ပြီးဖြစ်ဖြစ် စဉ်းစားပြီးဖြစ်ဖြစ် ဒီ code ဟာ ဘာလုပ်သင့်တယ် မဟုတ်ပဲ၊ ဒီလိုအလုပ်လုပ်ရမယ်လို့ အသေအချာသိတာကိုပြောတာပါ။
 
ဖြစ်နိုင်ခြေက ကျနော်တို့က ကျနော်တို့ program တွေရဲ့ မှန်ကန်မှုကို test suites တွေ run လို့ရတဲ့ အဖြေပေါ်မှာ မှီခိုလေ့ ရှိပါတယ်။ tests တွေက မကောင်းဘူး လို့ မဆိုလိုပါဘူး။ ဒါပေမယ့် test suite တွေ မ run ကြည့်ခင် ဒီ test suite တွေ pass မယ်လို့ ကိုယ့် code ကိုယ် ကောင်းကောင်း နားလည်သင့်ပါတယ်။ 

FP ရဲ့ အခြေခံ နည်းစနစ်က ကိုယ့်ရဲ့ program ကို ဖတ်ကြည့်ယုံနဲ့ ယုံကြည်မှုရှိရမယ်ဆိုတဲ့ အပေါ်မှာ ဖွဲ့စည်းထားတာပါ။ ကိုယ့်ရဲ့ program မှာသုံးဖို့ FP ကို ဂရုတစိုက် နိုင်နိုင်နင်းနင်း သိတဲ့ သူဟာ သူကိုယ်တိုင်နဲ့ **တခြားသူ**တွေရော သူတို့ လိုချင်တဲ့ အတိုင်း အလုပ်လုပ်မယ်လို့ အသေအချာသိအောင် code တွေရေးမှာပါ။

bugs တွေအနည်းဆုံး သို့မဟုတ် မရှိတဲ့ နည်းစနစ်တွေ သုံးတဲ့ အခါ ယုံကြည်မှုလည်းမြင့်တက်လာပါတယ်။ အဲ့ဒါက FP ရဲ့ အကြီးဆုံး အားသာချက်လည်း ဖြစ်နိုင်ပါတယ်။ FP program တွေက bugs နည်းတယ်၊ ရှိရင်လည်း ထင်ရှားတဲ့ နေရာတွေမှာ ရှိတယ်၊ အဲ့ဒီ အတွက် ရှာပြီး ပြင်ဆင်ဖို့ လွယ်တယ်။ FP code တွေက bugs နည်းလေ့ ရှိပေမယ့် လုံးဝ မရှိဘူးပြောတာ မဟုတ်ပါဘူး။

ဒီစာအုပ်ဖတ်ရင်း  သင်ဟာ ယုံကြည်စိတ်ချရတဲ့ patterns တွေ practices တွေကို သုံးရင်း program bugs ဖြစ်လေ့ရှိတဲ့ အကြောင်းရင်းတွေ ရှောင်နိုင်မှာ ဖြစ်တဲ့ အတွက် သင်ရေးတဲ့ code ကို သင်ပိုယုံကြည်လာမှာပါ

## Communication

FP ဘာလို့ အရေးကြီးတာလဲ။ အဲ့ဒါကိုဖြေဖို့ ခပ်ဝေးဝေး နောက်ပြန်ဆုတ်ပြီး programming ကိုယ်တိုင်ကိုက ဘာလို့ အရေးကြီးတာလဲ ပြောဖို့လိုအပ်ပါတယ်။

သင်ဒါကိုကြားရင် အံ့သြမှာပါ။ ဒါပေမယ့် code ဆိုတာ computer အတွက် ညွှန်ကြားချက် အစုအဝေးလို့ ကျနော်တော့ မယုံပါဘူး။  တကယ်တော့ ကျနော်တော့ computer ကို code က ညွှန်ကြားတယ် ဆိုတာ မတော်တဆ ဖြစ်သွားတာပါ။

code ရဲ့ ပိုအရေးကြီးတဲ့ အပိုင်းက လူသားတွေ အချင်းချင်း ဆက်သွယ်ဖို့လို့ ကျနော် နက်နက်ရှိုင်းရှိုင်း ယုံကြည်ပါတယ်။

သင့်ရဲ့ coding အချိန်တော်တော်များများက ရှိပြီးသား code တွေဖတ်ရင်း ကုန်သွားတယ်ဆိုတာ အတွေ့အကြုံအရ သင်သိရင်သိမှာပါ။ လူအနည်းငယ်ပဲ အချိန်အများစုကို တခြားသူ(ကိုယ်ကိုယ်တိုင်) ရေးထားတဲ့ code တွေကြည့်စရာ မလိုပဲ code အသစ်တွေနဲ့ အချိန်ကုန်ခွင့်ရှိတာပါ။

 developer တွေရဲ့ အချိန် 70% ကို code ကို maintenance လုပ်ဖို့ ဖတ်ပြီး နားလည်ဖို့ ကြိုးစားရင်း ကုန်ဆုံးသွားတယ်လို့ တော်တော်များများ ခန့်မှန်းကြတယ်။ ဒါက မျက်စိပွင့်စေပါတယ်။ တကမ္ဘာလုံး အတိုင်းအတာနဲ့ ယှဉ်ရင် programmer တစ်ယောက်ရဲ့ တစ်နေ့ ရေးတဲ့ code အကြောင်းရေ 10 ကြောင်းလောက်ပဲရှိတာ အံသြစရာ မဟုတ်ပါဘူး။ ကျနော်တို့ဟာ ကျနော်တို့ရဲ့ တစ်နေ့တာကို အဲ့ဒီ code 10 ကြောင်း ဘယ်နားသွားရေးရမလဲ တွေးနေရတာနဲ့ အချိန်ကုန်တာပါ။

ကျနော်တော့ ကျနော်တို့ code တွေရဲ့ readability ကို ပို ဂရုစိုက်သင့်တယ် ထင်ပါတယ်။ ပြီးတော့ စကားမစပ် readability ဆိုတာ code အကြောင်းရေ တိုခြင်းနဲ့ မဆိုင်ပါဘူး။ Readability ဆိုတာ တကယ်တော့ သင်နဲ့ code နဲ့ ဘယ်လောက် ရင်းနှီးမှု ရှိလည်းဆိုတာနဲ့ တိုင်းတာတာပါ။

ကျနော်တို့ အချိန်တွေကို ဖတ်လွယ် နားလည်လွယ်အောင် ကြိုးစားမယ်ဆိုရင် FP က အဲ့ဒီ ကြိုးစားမှုမှာ အချက်အချာ ကျပါတယ်။ FP ရဲ့ စည်းကမ်းတွေဟာ အခြေကျပြီးသား၊ နက်နက်နဲနဲ လေ့လာပြီးသား ဖြစ်ပြီး သက်သေလည်းပြနိုင်ပါတယ်။ အဲ့ဒီ FP စည်းကမ်းတွေကို အချိန်ယူ သင်ပြီး အသုံးချခြင်းက သင်ကိုယ်တိုင် အတွက်ရော တခြားသူတွေ အတွက်ပါ လွယ်လွယ်ကူကူနဲ့ ရင်းနှီး မှတ်မိလွယ်တဲ့ code  တွေအဖြစ် ဉီးတည်စေမှာပါ။ code ရဲ့ ရင်းနှီးမှု နဲ့ မှတ်မိလွယ်မှု တိုးလာတာက code readability ပါ တိုးတက်စေပါတယ်။

ဉပမာ သင်က `map(..)` ဘယ်လိုအလုပ်လုပ်လဲ နားလည်ရင် တခြားဘယ် program မှာပဲ မြင်မြင် ချက်ခြင်းနားလည်နိုင်ပါတယ်။ ဒါပေမယ့် သင် `for`loop ကို မြင်တဲ့ အကြိမ်တိုင်းတော့ နားလည်ဖို့  loop တစ်ခုလုံး ဖတ်ရမှာပါ။ `for` loop ရဲ့ syntax ကို ရင်နှီးပေမယ့် ဘယ်လို အလုပ်လုပ်လဲကတော့ အမြဲတမ်း ဖတ်ကြည့်မှ သိရမှာပါ။

ကြည့်တာနဲ့ မှတ်မိတဲ့ code များများ ရှိခြင်းအားဖြင့် ဒီ code ဘယ်လို အလုပ်လုပ်လဲ တွေးရနဲပြီး ကျနော်တို့ရဲ့ အာရုံစိုက်မှုက ပိုအရေးကြီးတဲ့ program logic ကို တွေးနိုင်ပါတယ်။ အာရုံစိုက်ဖို့ အများဆုံးလိုအပ်တာကလည်း program logic ပါပဲ။

FP (အနည်းဆုံးတော့ အချက်အလက်တွေ အကုန်လုံး မနှိုင်းယှဉ်ဘဲ) readable code တွေ တည်ဆောက်ဖို့ အထိရောက်ဆုံး tools တွေထဲက တစ်ခုပါပဲ။ အဲ့ဒါကြောင့်ပဲ အရမ်းအရေးကြီးတာပါ။

## Readability

Readability က binary characteristic မဟုတ်ပါဘူး။ ကျနော်တို့တွေနဲ့ code တွေ ဘယ်လို ဆက်စပ်မှု ရှိလဲ ဆိုတာ လူသားတွေ ထည့်သွင်းစဉ်းစားတဲ့ အချက်အလက် ပေါ်မှာပဲ မူတည်ပါတယ်။ ကျနော်တို့ရဲ့ အရည်အချင်းတွေ နားလည်မှု ပေါ်မူတည်ပြီး ကျနော်တို့ရဲ့ အချိန်တွေက ကွဲပြားမှာပါ။
 
အောက်က ပုံလိုမျိုး သက်ရောက်မှုကို ကျနော်လည်း ခံစားဖူးတယ်။ ပြီးတော့ ကျနော်နဲ့ စကားပြောဖူးတဲ့ လူတော်တော်များများရောပဲ။

<p align="center">
    <img src="fig17.png" width="600">
</p>

ဒီစာအုပ်အတိုင်း လိုက်လုပ်ရင်း သင်လည်း ပုံစံတူ ခံစားရနိုင်ပေမယ့် မပူပါနဲ့ ဆက်သာလုပ်သွားပါ။ curve က ပြန်တက်လာမှာပါ။

*Imperative* ဆိုတာ ကျနော်တို့ ရေးလေ့ ရှိတဲ့ code တွေကို ပြောတာပါ။ computer ကို တိတိကျကျ ဘယ်လို အလုပ်လုပ်ရမလဲ ညွှန်ကြားဖို့ အာရုံစိုက်တာပါ။ Declarative code က FP စည်းမျဉ်းအတိုင်း ရေးဖို့သင်မယ့် အမျိုးအစားပါ။ ဘယ်လို outcome မျိုး ဖြစ်ရမလဲ ဆိုတဲ့ အပေါ်ပိုအာရုံထားပါတယ်။

အခု chapter အစက code snippets နှစ်ခုကို ပြန် ဆန်းစစ်ရအောင်။

ပထမ snippet က task ကို ဘယ်လို လုပ်ရမလဲ ဆိုတဲ့ အပေါ်မှာ လုံးဝ အာရုံစိုက်ထားတဲ့ imperative ပါ။  `if` statements, `for` loops တွေ, temporary variables တွေ, reassignments တွေ, value mutations တွေ, side effects ရှိတဲ့ function calls တွေ ပြီးတော့ function တွေကြားမှာ ဆက်စပ်နေတဲ့ data flow တွေ နဲ့ ရှုပ်နေပါတယ်။ အဲ့ဒီ numbers တွေ နောက်ဆုံး အဆင့်ကို ဘယ်လို ပြောင်းလဲသွားတယ်ဆိုတာ သင် သူ့ရဲ့ logic ကို ဆန်းစစ်နိုင်ပါတယ်။ ဒါပေမယ့် အကုန်လုံး နားလည်မလွယ်သလို ရှင်းရှင်းလင်းလင်းလဲ မရှိပါဘူး။

ဒုတိယ snippet ကတော့ ပိုပြီး declarative ဖြစ်ပြီး ရှေ့ကပြောခဲ့တဲ့ imperative နည်းတွေ မသုံးထားပါဘူး။ explicit conditionals တွေ, loops တွေ, side effects တွေ, reassignments တွေ, mutations တွေ မရှိတာ သတိထားမိလား။  အဲ့ဒီအစား နာမည်ကြီး ပြီး စိတ်ချရတဲ့ filtering, reduction, transducing, and composition လို patterns တွေသုံးထားပါတယ်။ အာရုံစိုက်မှုတွေက low-level *how* ကနေ higher level *what* outcomes ကို ပြောင်းသွားပါပြီ။

number တစ်ခုကို စမ်းသပ်ဖို့ `if` statement တစ်ခု သုံးမည့် အစား ကျနော်တို့က FP ရဲ့ အသုံးဝင်တဲ့ `gte(...)` (greater-than-or-equal-to) လို function တစ်ခုကို တာဝန်လွဲလိုက်ပြီး ပိုအရေးကြီးတဲ့ အဲ့ဒီ filter ရယ် တခြား filter တစ်ခုရယ် ပေါင်းခြင်းကိုလုပ်ဆောင်တဲ့ function တစ်ခုရယ် အဲ့ဒီသုံးခု ဘယ်လိုပေါင်းရမလဲ ဆိုတဲ့ အပေါ် အာရုံစိုက်ပါတယ်။

ဒါ့အပြင် ဒုတိယ program ရဲ့ data စီးဆင်းမှုက ရှင်းလင်းပါတယ်။

1. numbers တွေက `printMagicNumber(..)` ထဲသွားတယ်။
2. အဲ့ဒီ numbers တွေ တစ်ခုချင်းက `sumOnlyFavourites(..)` က processed လုပ်ပြီး ကျနော်တို့ favorite အမျိုးအစားတွေချည်း ပေါင်းထားတဲ့ number တစ်ခုတည်း ဖြစ်လာတယ်။
3. စုစုပေါင်းကို message တစ်ခုအဖြစ် `constructMsg(..)`သုံးပြီး ပြောင်းတယ်။
4. အဲ့ဒီ message ကို `console.log(..)`သုံးပြီး print ထုတ်တယ်။

ရှုပ်ထွေးပြီး လိုက်လုပ်ဖို့ ခက်ခဲတယ် imperative snippet က ပိုလွယ်တယ် လို့  သင်ဟာ ခံစားရတုန်းပဲ ဖြစ်နိုင်ပါတယ်။  ကျနော်တို့ရဲ့ readability ကို ဆုံးဖြတ်ကြတဲ့ အခါ ရင်းနှီးမှုမှာ နက်ရှိုင်းတဲ့ လွှမ်းမိုးမှု တစ်ခုရှိလို့ သင်ကပိုပြီး အကျွမ်းတဝင် ရှိတယ် ခံစားရတာပါ။

ဒီစာအုပ်ဖတ်ပြီးတဲ့ အခါ သင်ဟာ ဒုတိယ snippet ရဲ့ declarative ချည်းကပ်မှုနဲ့ အသားကျပြီး ရင်းနှီးမှုကနေ readability ဆီကို ပြောင်းလဲစေမှာပါ။

အခုအချိန်မှာ သင့်ကို ယုံခိုင်းတာက ယုံခိုင်းခြင်းသက်သက်ပဲဆိုတာ သိပါတယ်။

ကြိုးစားအားထုတ်မှု အများကြီးလိုအပ်ပြီး  ကျနော်အကြံပြုသလို readability တိုးတက်ဖို့ bugs တွေအဖြစ် ပြောင်းသွားမယ့် အမှားတွေ အများကြီးကို ဖယ်ရှားဖို့  တစ်ခါတစ်လေ code ပိုများပါတယ်။ ရိုးရိုးသားသား ဝန်ခံရရင် ဒီစာအုပ်စရေးတော့ ဒုတိယ snippet ကို မရေးနိုင်ခဲ့ဘူး၊ (အပြည့်အဝလည်း နားမလည်ခဲ့ဘူး)။ ဆက်လက်သင်ယူရင်းနဲ့မှ ပိုပြီး သဘာဝ ကျလာ၊ သက်တောင့်သက်သာ ရှိလာတာပါ။

FP refactoring က magic silver bullet လို မြန်မြန်ဆန်ဆန် လှလှပပ၊ သပ်သပ်ရပ်ရပ်နဲ့  ပုံမှန်အတိုင်းပြန်ဖြစ်ပြီး အတိုချုပ်ပြောရရင် ပိုလွယ်ကူလာစေချင်ရင်တော့ လက်တွေ့ဆန်တဲ့ မျှော်လင့်ချက်တစ်ခု မဟုတ်ဘူးပေါ့။ 

FP က code တွေကို ဘယ်လို structured ချမလဲ၊ သင်တွေးသလို လိုက်တွေးနိုင်အောင် code ဖတ်တဲ့သူကို ဘယ်လို ကူညီမလဲ၊ data flow ကို ဘယ်လို ပိုထင်ရှားအောင် လုပ်မလဲ ဆိုတဲ့ လုံးဝ မတူတဲ့ တွေးပုံတွေးနည်းပါ။ အချိန်ယူရမှာပါ။ အဲ့လိုမျိုး အားထုတ်မှုက လုံးဝ ထိုက်တန်ပါတယ်။ ဒါပေမယ့် ခက်ခဲတဲ့ ခရီးတစ်ခုဖြစ်နိုင်ပါတယ်။

 snippet တစ်ခုကို imperative code ကနေ declarative FP အဖြစ်ကို refactoring လုပ်တဲ့အခါ နောင်တစ်ချိန် ပြန်ကြည့်ရင် ကျနော့အတွက် နားလည်လွယ်တဲ့ အခြေအနေ မရောက်ခင် အကြိမ်များစွာ ကြိုးစားရလေ့ရှိပါတယ်။ FP အဖြစ်ပြောင်းရတာ နှေးတဲ့ process တစ်ခုပါ။
 
ကျနော်ရေးတဲ့ code တွေအကုန်လုံးကို "နောင်တစ်ချိန်မှာ ပြန်သင်ပါ" နည်းနဲ့ စမ်းပါတယ်။ code တစ်ခု ရေးပြီးတဲ့ အခါ နာရီ အနည်းငယ် ဒါမှမဟုတ် ရက်အနည်းငယ် ပြစ်ထားလိုက်တယ်။ ပြီးမှ တစ်ယောက်ယောက်ကို ပြန်သင်ရမယ် ပြန်ရှင်းပြရမည့်အတိုင်း ဖတ်ကြည့်တယ်။ များသောအားဖြင့်တော့ ရှုပ်နေလို့ ပြန်ပြင်ရတယ်။ အဲ့ဒီအတိုင်း repeat လုပ်ပါတယ်

သင့်ကိုစိတ်ပျက်အောင်ပြောနေတာတော့ မဟုတ်ပါဘူး။ သင့်ကို အဲ့ဒါတွေအကုန်ဖြတ်ကျော်စေချင်တာပါ။ ကျနော်တော့ အောင်မြင်ပြီးပါပြီ။ readability ဆီကို curve က နောက်ဆုံးမှာ ထောင်တက်လာတာ မြင်နိုင်ပါပြီ။ ကြိုးစားရကြိုးနပ်ပါတယ်။ သင်လည်း အဲ့ဒီလို ဖြစ်လာမှာပါ။


## Perspective
ကျနော်တို့စခု FP ကို အစကနေ ချည်းကပ်ပါ့မယ်။ သမရိုးကျ FP ရေးသူတွေကတော့ သူတို့လုပ်ပုံလုပ်နည်း scaffolding လို့ပြောတဲ့  အခြေခံ စည်းကမ်းတွေကို လေ့လာသွားမှာပါ။   ကျနော့ အမြင်တော့ တခြား FP စာအုပ်တွေနဲ့ က ပြောင်းပြန်နည်း top-down နဲ့ သွားပါတယ်။ အချိန်တော်တော်များများကိုတော့ သင်ယူသူတွေကို အလွယ်တကူ စိတ်ရှုပ် ကြောက်လန့်စေတဲ့ အသုံးအနှုန်း (သို့) သင်္ချာ သင်္ကေတ တွေနဲ့ ဝေးနိုင်သမျှဝေးဝေးမှာ နေမှာပါ။

သင်ဟာ တစ်ခုခုဆို ဘယ်လိုခေါ်လဲ ဆိုတာထက် အဲ့ဒါကဘာလဲ၊ ဘယ်လို အလုပ်လုပ်လဲ ဆိုတာ နားလည်ဖို့က ပိုအရေးကြီးတယ်လို့ ကျနော်ယုံကြည်ပါတယ်။ အဲ့လိုပြောတာက အသုံးအနှုန်းတွေကို ပြန်လည်ရှင်းပြ ဖြန့်ဝေဖို့ အရေးမကြီးဘူး ပြောတာမဟုတ်ပါဘူး။ အဲ့ဒါက အတွေ့အကြုံရှိပြီးသား professionals ကြားမှာ ဆက်သွယ်မှုတွေကို ပိုမိုလွယ်ကူစေတာကတော့ သံသယ မရှိပါဘူး။  သင်ယူသူ အတွက်ကတော့ အာရုံပျံ့လွှင့်စေပါတယ်။

ဒီစာအုပ်က အထင်ကြီးစေတဲ့ အသုံးအနှုန်းတွေလျော့ပြီး အခြေခံ သဘောတရားတွေကို ပိုအလေးပေးသွားမှာပါ။ အဲ့ဒီအသုံးအနှုန်းတွေ မပါတော့မှာတော့ မဟုတ်ပါဘူး။ အသေအချာပါမှာပါ။ အဲ့ဒီအသုံးအနှုန်းတွေပေါ်မှာ အရမ်းမသာယာပါနဲ့။ ဘယ်လိုပဲဖြစ်ဖြစ် ပြောချင်တဲ့ အရေးကြီးသဘာတရားကိုတော့ မြင်အောင်ကြည့်ပါ။
 
ကျနော်က ဒီနေရာမှာ သုံးနေကျ မဟုတ်တဲ့ "Functional-Light Programming" လို့ခေါ်ပါတယ်။ ဘာလို့လဲဆိုတော့ 
သမရိုးကျ FP အစစ်အမှန် ဆိုရင် သင်ဟာ သမရိုးကျ အတွေးအခေါ်(စာအုပ်ကြီးအတိုင်း) နဲ့ အကျွမ်းတဝင် မရှိပါက နားလည်ရခက်မှာမို့လို့ပါ။ ကျနော် ခန့်မှန်းကြည့်နေတာ မဟုတ်ပါဘူး။ ကိုယ်ပိုင် အတွေ့အကြုံပါ။ FP ကိုသင်ကြားနေပြီး ဒီစာအုပ်ရေးပြီးတဲ့ အချိန်မှာတောင် သမရိုးကျ အသုံးအနှုန်းတွေ အမှတ်အသားတွေက ကျနော့်အတွက် နားလည်မှတ်မိဖို့ အရမ်းခက်ခဲပါတယ်။ ကြိုးစားခဲ့တယ် ဒါပေမယ့် များများတော့ ရခဲ့ပုံမပေါ်ဘူး။

FP သင်ယူသူ တော်တော်များများက သမရိုးကျ အသုံးအနှုန်းတွေဟာ သင်ကြားရေးမှာ အသုံးဝင်တယ်လို့ ယုံကြည်ကြတာ သိပါတယ်။ အဲ့လိုယုံကြည်ဖို့ကလဲ သမရိုးကျ အသုံးအနှုန်းတွေ နဲ့ ရင်းနှီးပြီးသား အခြေအနေတစ်ခုကိုရောက်ဖို့ တော်တော်မလွယ်ဘူးဆိုတာလဲ ရှင်းပါတယ်။ သင်က သင်္ချာနဲ့ပဲဖြစ်ဖြစ် CS အတွေ့အကြုံ နဲ့ပဲဖြစ်ဖြစ် ရင်းနှီး နှစ်သက်ပြီးသားသူ ဆိုရင်တော့ သင့်အတွက် မခက်ပါဘူး။ ကျနော်တို့ အချို့ အတွက်ကတော့ ဘယ်လောက်ပဲကြိုးစား ကြိုးစား သမရိုးကျ အသုံးအနှုန်းတွေ က ရှေ့မှာ ကန့်လန့်ခံနေဆဲပါ။

ဒီစာအုပ်က FP ကို ဘယ်လိုတည်ဆောက်ထားတယ် ဆိုတဲ့ သဘောတရားတွေကို ရှင်းပြထားပါသော်လည်း သင့်ကို အပေါ်စီးကနေ သင်လိုက်လုပ်မှ ဟိုလိုလုပ်ပါ ဒီလိုလုပ်ပါ ဆိုတာမျိုး မဟုတ်ပဲ အောက်ခြေကနေ အပေါ်ရောက်အောင် တွန်းအားတစ်ခု ပေးသွားမှာပါ။


## How To Find Balance

သင်က programming မှာ ရင်းနှီးပြီးသားသူ ဆိုရင် သင်အရင်က "YAGNI" ဆိုတဲ့ အသုံး အနှုန်းကို ကြားဖူးကောင်းကြားဖူးမှာပါ။ သင့်အတွက် အဲ့ဒါ မလိုပါဘူး။ ဒီစည်းမျဉ်းက တင်းကျပ်တဲ့ programming ဆီကနေ လာတာပါ။ ပြီးတော့ တကယ်တန်း အသုံးမလိုသေးခင်မှာ feature တစ်ခုဆောက်တဲ့ ကုန်ကျစရိတ်နဲ့ တခြား အန္တရာယ် တွေကိုလည်း တွေးပြီး စိတ်ဖိစီးစေပါတယ်။ 

တစ်ခါတစ်လေမှာ ကျနော်တို့က feature တစ်ခုလိုအပ်မယ်၊ အဲ့ဒါက တခြား feature တွေ ထပ်ဆောက်ရင်လည်း ပိုအသုံးဝင်မယ် လို့ ထင်ပြီး ဆောက်လိုက်မယ်၊ ဒါပေမယ့် ကျနော်တို့ ခန့်မှန်းတာ မှားပြီး အဲ့ဒီ feature က မလိုအပ်ဘူး၊ အဲ့ဒါထက်နဲနဲကွဲတဲ့ ပုံစံကို လိုအပ်တာဆိုတာ နောက်မှသိတယ်။ တစ်ခါတစ်လေမှာ ခန့်မှန်းတာတော့မှန်ပေမယ့် feature ကို စောပြီးဆောက်လိုက်လို့ အခုလိုအပ်နေတဲ့ feature ဆီက အချိန်တွေယူသွားသလို့ ကျနော်တို့ရဲ့ ခွန်အားတွေလည်း ဆုံးရှုံးစေတယ်။

YAGNi ရဲ့ စိန်ခေါ်မှုက ကျနော်တို့ကို အခြေအနေ တစ်ခုမှာ မျှော်လင့်ထားသလိုဖြစ်မလာရင် တစ်ခုခုလုပ်ဖို့ လက်တလော မလိုသေးရင် နောက်မှလုပ်သင့်တယ်ဆိုတာ  မှတ်မိနေစေဖို့ပါ။ ကျနော်တို့က နောင်တစ်ချိန်မှာ လိုအပ်မှ ထပ်ထည့်မယ်ဆိုရင် စိတ်မှန်းနဲ့ ဘယ်လောက်ပင်ပန်းမလဲ ဆိုတာကို ချဲ့ကား ပြောလေ့ရှိပါတယ်။ တကယ်တော့ နောက်မှလုပ်မယ်ဆိုတာက ထင်ထားသလောက် အရမ်းမခက်ပါဘူး။

အဲ့ဒီ အယူအဆကို functional programming မှာ သုံးမယ်ဆိုရင် ကျနော် သတိပေးချင်တာက 
ဒီစာအုပ်မှာ ဆွေးနွေးမည့် pattern တော်တော်များများက စိတ်ဝင်စားဖို့ကောင်းပါတယ်။ ဒါပေမယ့် သင်က တချို့ pattern တွေက သုံးလိုက်ရင်ကောင်းမယ်ထင်တိုင်း သင့် code တွေမှာ လိုက်တော့ မပြောင်းသင့်ပါဘူး။

FP ကို သုံးလိုက်လို့ ရတယ်ဆိုတိုင်း သုံးသင့်တယ် မဆိုလိုပါဘူး ပြောတဲ့အတွက် ဒီနေရာမှာ ကျနော်နဲ့ တခြား သမရိုးကျ FP အကြောင်း ရှင်းပြ ပြောပြသူတွေနဲ့ ကွဲပြားတာပါ။ ဒါ့အပြင် ပြသနာ တစ်ခုကို ခွဲခြမ်းစိတ်ဖြာမယ်ဆို နည်းအများကြီး ရှိပြီး သင်ဟာ နောင်တစ်ချိန် မှာ maintenace လုပ်ရလွယ်မယ်၊ extend လုပ်ရလွယ်မယ့်  ပိုကောင်းတဲ့ နည်းတွေ သိပြီးသား ဖြစ်ပေမယ့်လည်း ရိုးရှင်းတဲ့ FP pattern တစ်ခုက အချို့နေရာမှာ ပိုသင့်တော်မှာပါ။
 
ခြုံပြောချင်တာက သင့် code ရဲ့ balance နဲ့ FP ရဲ့ သဘောတရားတွေကို သုံးပြီး သင့်ရဲ့ application မှာ ဘယ်နေရာမှာတော့ ဘယ်လိုပြင်သင့်တယ်ဆိုတာ ရှာဖို့ အကြံပြုချင်တာပါ။  YAGNI စည်းမျဉ်းအရ pattern တစ်ခု၊ abstraction တစ်ခုက သင့် code ကို ဖတ်ရ ပိုလွယ်သွားတာလား ဒါမှမဟုတ် မလိုအပ်ပဲ ပိုကောင်းသွားတာလား ဆိုတာ ဆုံးဖြတ်ဖို့ ကူညီပေးမှာပါ။

> Reminder, any extensibility point that’s never used isn’t just wasted effort, it’s likely to also get in your way as well
>
> Jeremy D. Miller @jeremydmiller 2/20/15
>
> https://twitter.com/jeremydmiller/status/568797862441586688

သင်ရေးတဲ့ code line တိုင်းက ဖတ်တဲ့သူကို သက်ရောက်မှု ရှိပါတယ်။ ဖတ်သူဆိုတာ အခြား team member တစ်ယောက်ဖြစ်နိုင်သလို သင်ကိုယ်တိုင်လည်း ဖြစ်နေနိုင်ပါတယ်။ သင်က မလိုအပ်ပဲ သင်ဘယ်လောက် FP သုံးတတ်တယ်ဆိုတာ ပြထားရင်တော့ ဘယ်သူပဲဖြစ်ဖြစ်  အထင်ကြီးမှာ မဟုတ်ပါဘူး။

အကောင်းဆုံး code ဆိုတာ ဘယ်လို အလုပ်လုပ်နိုင်တယ်၊လုပ်သင့်တယ်(idealism) ဆိုတာနဲ့ ဘယ်လိုအလုပ်လုပ်ရမယ်(pragmatism) ဆိုတဲ့  balance ကို ထိန်းနိုင်ပြီး နောင်တစ်ချိန်မှာ ဖတ်ရ အလွယ်ဆုံး ဖြစ်တဲ့ code ကို ပြောတာပါ။


## Resources

ဒီစာ ရေးဖို့ resources အမျိုးမျိုးကြားမှာ ပင်ပန်းပြီးပါပြီ။ သင်လည်း အကျိုးရှိမယ်လို့ ယုံတဲ့ အတွက် ဘယ် resources တွေလည်း ဆိုတာ ပြောပြပါ့မယ်။


### Books

သင်လုံးဝ ဖတ်သင့်တဲ့ FP/JavaScript စာအုပ် အချို့ အနေနဲ့ 

* [Professor Frisby's Mostly Adequate Guide to Functional Programming](https://drboolean.gitbooks.io/mostly-adequate-guide/content/ch1.html) by [Brian Lonsdorf](https://twitter.com/drboolean)
* [JavaScript Allongé](https://leanpub.com/javascriptallongesix) by [Reg Braithwaite](https://twitter.com/raganwald)
* [Functional JavaScript](http://shop.oreilly.com/product/0636920028857.do) by [Michael Fogus](https://twitter.com/fogus)

### Blogs/Sites

သင်လိုက်ကြည့်သင့်တဲ့ စာရေးသူတွေနေ့ အချက်အလက် အချို့

* [Fun Fun Function Videos](https://www.youtube.com/watch?v=BMUiFMZr7vk) by [Mattias P Johansson](https://twitter.com/mpjme)
* [Awesome FP JS](https://github.com/stoeffel/awesome-fp-js)
* [Kris Jenkins](http://blog.jenkster.com/2015/12/what-is-functional-programming.html)
* [Eric Elliott](https://medium.com/@_ericelliott)
* [James A Forbes](https://james-forbes.com/)
* [James Longster](https://github.com/jlongster)
* [André Staltz](http://staltz.com/)
* [Functional Programming Jargon](https://github.com/hemanth/functional-programming-jargon#functional-programming-jargon)
* [Functional Programming Exercises](https://github.com/InceptionCode/Functional-Programming-Exercises)

### Libraries

ဒီစာအုပ်ထဲက code snippets တွေဟာ libraries တွေပေါ်မှာ မမှီခိုပါဘူး။ ကျနော်တို့ ရှာတွေ့တဲ့ လုပ်ဆောင်ချက် တစ်ခုခြင်းက JavaScript ပဲသုံးပြီး ဘယ်လို လုပ်ရမလဲဆိုတာ သိလာမှာပါ။ ဒါပေမယ့် တစ်ကယ်သုံးမည့် FP code တွေရေးလာလေလေ အဲ့ဒီ လိုအပ်ချက်တွေကို optimized လည်းလုပ်ထားတယ်၊ လုံးဝလဲ ယုံကြည်ရတယ် ဆိုတဲ့ library တစ်ခု လိုချင်လာမှာပါ။ 

စကားမစပ် library functions တွေသုံးမယ်ဆို အဲ့ဒီ functions တွေ ဘယ်လို အလုပ်လုပ်လဲ ဆိုတာ documentation တော့ ဖတ်ပါ။ ဒီစာအုပ်မှာ ရေးမည့် code တွေနဲ့ ဆင်တူတွေ ရှိလာနိုင်ပေမယ့် နာမည်ကြီး library တွေနဲ့ ယှဉ်ရင် မတူတာတွေလည်းရှိလာမှာပါ။

သင်စလေ့လာမယ်ဆို ဒါတွေက နာမည်ကြီး FP libraries တွေပဲဖြစ်ကြပါတယ်။

* [Ramda](http://ramdajs.com)
* [lodash/fp](https://github.com/lodash/lodash/wiki/FP-Guide)
* [functional.js](http://functionaljs.com/)
* [Immutable.js](https://github.com/facebook/immutable-js)

Appendix C takes a deeper look at these libraries and others.

## Summary

သင့်မှာ ဒီစာအုပ် ဖတ်ဖို့အတွက် အကြောင်းပြချက်တွေ ဒီစာအုပ်ကနေ ဘာလိုချင်တယ်ဆိုတဲ့ မျှော်လင့်ချက်တွေလည်း ရှိမှာပါ။ 
ဒီ chapter မှာ သင့်ကို ဘာဖတ်စေချင်တယ် ဘာရစေချင်လဲ ဆိုတာ ရှင်းပြပြီးပါပြီ။ သင်ကနေ သင့်ရဲ့ သူငယ်ချင်း developers တွေကို ဘာလို့ ဒီစာအုပ်ဖတ်သင့်လဲ ဆိုတာ ရှင်းပြနိုင်စေမှာပါ။

FP ဆိုတာ ကျနော်တို့ရေးတဲ့ ဖတ်တဲ့ code တွေကို ယုံကြည့်မှု အဆင့်တစ်ခုထိ ရစေမည့် စည်းမျဉ်းတွေအပေါ် အခြေခံထားတဲ့ code ရေးနည်း တစ်ခု ဖြစ်ပါတယ်။ စိုးရိမ်တကြီး နှင့် အလုပ်လုပ်ပါစေ မျှော်လင့်ပြီး test suite တွေ pass သွားမှ သက်ပြင်းချနိုင်ယုံလောက်နဲ့ မကျေနပ်သင့်ပါဘူး။ run မကြည့်ခင်ကတည်းက ဘယ်လို အလုပ်လုပ်မလဲ ဆိုတာ သိသင့်ပြီး ကျနော်တို့ရဲ့ code တွေကနေ ဖတ်သူတွေ (နောင်တစ်ချိန်မှာ ကိုယ်ကိုယ်တိုင်) အကျိုးအတွက် လုံးဝ အကျိုးရှိတယ်ဆိုတာ ယုံကြည်ချက် ရှိသင့်ပါတယ်။

ဒါက Functional-Light JavaScript ရဲ့ အရေးအကြီးဆုံး အပိုင်းပါပဲ။ ရည်ရွယ်ချက်က ကျနော်တို့ရဲ့ code တွေနဲ့ ထိထိရောက်ရောက် ဆက်သွယ်နိုင်အောင်သင်နိုင်ဖို့ဖြစ်ပြီး အမှတ်အသားတွေ အသုံးအနှုန်းတွေအောက်မှာ ကျဆုံးသွားဖို့ မဟုတ်ပါဘူး။

functional programming သင်ယူခြင်း ခရီးမှာ function ရဲ့ သဘာဝ ကို နက်နက်ရှိုင်းရှိုင်း နားလည်ဖို့ ဆိုတာနဲ့ အစပြုပါတယ်။ နောက် သင်ခန်းစာ မှာ အဲ့ဒါ စလုပ်မှာပါ။

----

[1] Buse, Raymond P. L., and Westley R. Weimer. “Learning a Metric for Code Readability.” IEEE Transactions on Software Engineering, IEEE Press, July 2010, dl.acm.org/citation.cfm?id=1850615.